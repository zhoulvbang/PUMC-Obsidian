#Stata #常用命令
**help**和**search**都是查找帮助文件的命令，它们之间的**区别**在于**help用于查找精确的命令名**，而**search是模糊查找**。**如果你知道某个命令的名字，并且想知道它的具体使用方法，只须在[stata](https://zhida.zhihu.com/search?content_id=6839513&content_type=Article&match_order=1&q=stata&zhida_source=entity)的命令行窗口中输入help空格加上这个名字**。回车后结果屏幕上就会显示出这个命令的帮助文件的全部内容。**如果你想知道在stata下做某个估计或某种计算，而不知道具体该如何实现，就需要用search命令了**。使用的方法和**help**类似，只须把准确的命令名改成某个关键词。回车后结果窗口会给出所有和这个关键词相关的帮助文件名和链接列表。在列表中寻找最相关的内容，点击后在弹出的查看窗口中会给出相关的帮助文件。耐心寻找，反复实验，通常可以较快地找到你需要的内容。  
  
下面该正式处理数据了。我的处理数据经验是最好能**用stata的do文件编辑器记下你做过的工作**。因为很少有一项实证研究能够一次完成，所以，当你下次继续工作时。能够重复前面的工作是非常重要的。有时因为一些细小的不同，你会发现无法复制原先的结果了。这时如果有记录下以往工作的do文件将把你从地狱带到天堂。因为你不必一遍又一遍地试图重现做过的工作。在stata窗口上部的工具栏中有个孤立的小按钮，把鼠标放上去会出现“bring do-file editor to front”，点击它就会出现do文件编辑器。  
  
为了使do文件能够顺利工作，一般需要编辑do文件的“头”和“尾”。这里给出我使用的“头”和“尾”。  
**capture clear** （清空内存中的数据）  
**capture log close** （关闭所有打开的日志文件）  
**set more off** （关闭more选项。如果打开该选项，那么结果分屏输出，即一次只输出一屏结果。你按空格键后再输出下一屏，直到全部输完。如果关闭则中间不停，一次全部输出。）  
**set matsize 4000** （设置矩阵的最大阶数。我用的是不是太大了？）  
**cd D:** （进入数据所在的盘符和文件夹。和dos的命令行很相似。）  
**log using （文件名）.log,replace** （打开日志文件，并更新。日志文件将记录下所有文件运行后给出的结果，如果你修改了文件内容，replace选项可以将其更新为最近运行的结果。）  
**use （文件名）,clear** （打开数据文件。）  
（文件内容）  
**log close** （关闭日志文件。）  
**exit,clear** （退出并清空内存中的数据。）  
  
实证工作中往往接触的是**原始数据**。这些数据没有经过整理，有一些错漏和不统一的地方。比如，**对某个变量的缺失观察值，有时会用点，有时会用-9，-99等来表示**。回归时如果使用这些观察，往往得出非常错误的结果。还有，在不同的数据文件中，相同变量有时使用的变量名不同，会给合并数据造成麻烦。因此，拿到原始数据后，往往需要根据需要**重新生成新的数据库**，并且只使用这个新库处理数据。这部分工作不难，但是非常基础。因为如果在这里你不够小心，后面的事情往往会白做。  
  
假设你清楚地知道所需的变量，现在要做的是检查数据、生成必要的数据并形成数据库供将来使用。**检查数据的重要命令包括[codebook](https://zhida.zhihu.com/search?content_id=6839513&content_type=Article&match_order=1&q=codebook&zhida_source=entity)，su，ta，[des](https://zhida.zhihu.com/search?content_id=6839513&content_type=Article&match_order=1&q=des&zhida_source=entity)和list**。其中，**codebook提供的信息最全面，缺点是不能使用if条件限制范围，所以，有时还要用别的帮帮忙**。**su空格加变量名报告相应变量的非缺失的观察个数，均值，标准差，最小值和最大值**。**ta空格后面加一个（或两个）变量名是报告某个变量（或两个变量二维）的取值（不含缺失值）的频数，比率和按大小排列的累积比率**。**des后面可以加任意个变量名，只要数据中有。它报告变量的存储的类型，显示的格式和标签。标签中一般记录这个变量的定义和单位**。**list报告变量的观察值，可以用if或in来限制范围**。出了**ta**命令，其他命令都可以后面不加任何变量名，报告的结果是正在使用的数据库中的所有变量的相应信息。说起来苍白无力，打开stata亲自实验一下吧。  
  
顺带说点儿题外话。除了**codebook**之外，上述统计类的命令都属于 **r** 族命令（又称**一般命令**）。执行后都可以使用**return list**报告储存在r（）中的统计结果。最典型的**r**族命令当属**summarize**。它会把**样本量、均值、标准差、方差、最小值、最大值、总和等统计信息储存起来**。你在执行su之后，只需敲入return list就可以得到所有这些信息。其实，和一般命令的return命令类似，**估计命令**（又称 **e**族命令）也有**ereturn**命令，具有报告，储存信息的功能。**在更复杂的编程中，比如对回归分解，计算一些程序中无法直接计算的统计量，这些功能更是必不可少**。  
  
检查数据时，先用**codebook**看一下它的**值域和单位**。如果有-9，-99这样的取值，查一下问卷中对缺失值的记录方法。确定它们是缺失值后，**改为用点记录**。命令是`replace (变量名)=. if (变量名)==-9`。再看一下用点记录的缺失值有多少，作为选用变量的一个依据。  
  
得到可用的数据后，**我会给没有标签的变量加上注解**。或者统一标签；或者统一变量的命名规则。更改变量名的命令是**rename （原变量名）空格（新变量名）**。定义标签的命令是**label var （变量名）空格”（标签内容）**”。整齐划一的变量名有助于记忆，简明的标签有助于明确变量的单位等信息。  
  
**如果你需要使用通过原始变量派生出的新变量**，那么就需要了解**gen，[egen](https://zhida.zhihu.com/search?content_id=6839513&content_type=Article&match_order=1&q=egen&zhida_source=entity)**和**replace**这三个命令。gen和replace常常在一起使用。它们的基本语法是**gen (或replace)空格（变量名）＝（表达式）**。二者的**不同之处**在于gen是生成新变量，replace是重新定义旧变量。  
  
**虚拟变量是我们常常需要用到的一类派生变量**。如果你需要生成的虚拟变量个数不多，可以有两种方法生成。一种是简明方法：**gen空格（变量名）＝((限制条件))** [这外面的小括弧是命令需要的，里面的小括弧不是命令需要的，只是说明“限制条件”并非命令]。如果某个观察满足限制条件，那么它的这个虚拟变量取值为1，否则为0。另一种要麻烦一点。就是  
  
**gen （变量名）＝1 if （取值为一限制条件）**  
**replace（相同的变量名）＝0 if （取值为零的限制条件）**  
  
两个方法貌似一样，但有一个小小的区别。如果限制条件中使用的变量都没有任何缺失值，那么两种方法的结果一样。如果有缺失值，**第一种方法会把是缺失值的观察的虚拟变量都定义为0。而第二种方法可以将虚拟变量的取值分为三种，一是等于1，二是等于0，三是等于缺失值。**这样就避免了把本来信息不明的观察错误地纳入到回归中去。下次再讲如何方便地生成成百上千个虚拟变量。  
  
**大量的虚拟变量往往是根据某个已知变量的取值生成的。**比如，在某个回归中希望控制每个观察所在的社区，即希望控制标记社区的虚拟变量。社区数目可能有成百上千个，如果用上次的所说的方法生成就需要重复成百上千次，这也太笨了。大量生成虚拟变量的命令如下；  
  
**ta （变量名）, gen(（变量名）)**  
  
第一个括号里的变量名是已知的变量，在上面的例子中是社区编码。后一个括号里的变量名是新生成的虚拟变量的共同前缀，后面跟数字表示不同的虚拟变量。如果我在这里填入**d**，那么，上述命令就会新生成d1，d2，等等，直到所有社区都有一个虚拟变量。  
  
在回归中控制社区变量，只需简单地放入这些变量即可。一个麻烦是虚拟变量太多，怎么简单地加入呢？一个办法是用省略符号，**d*表示所有d字母开头的变量，另一法是用破折号，d1-d150表示第一个到第150个社区虚拟变量**（假设共有150个社区）。  
  
还有一种方法可以在回归中直接控制虚拟变量，而无需真的去生成这些虚拟变量。使用命令**areg**可以做到，它的语法是  
  
**areg （被解释变量） （解释变量）, absorb（变量名）**  
  
**absorb**选项后面的变量名和前面讲的命令中第一个变量名相同。在上面的例子中即为社区编码。回归的结果和在**reg**中直接加入相应的虚拟变量相同。  
  
生成变量的最后一招是**egen**。**egen**和**gen**都用于生成新变量，但**egen**的特点是它更强大的函数功能。**gen可以支持一些函数，egen支持额外的函数**。如果用gen搞不定，就得用egen想办法了。不过我比较懒，到现在为止只用用取平均、加和这些简单的函数。  
  
的时候数据情况复杂一些，往往生成所需变量不是非常直接，就需要多几个过程。曾经碰到原始数据中记录日期有些怪异的格式。比如，1991年10月23日被记录为19911023。我想使用它年份和月份，并生成虚拟变量。下面是我的做法：  
  
**gen yr=int(date)**  
**gen mo=int((data-yr*10000)/100)**  
**ta yr, gen( yd)**  
**ta mo, gen( md)**  
  
假设你已经生成了所有需要的变量，现在最重要的就是保存好你的工作。使用的命令是**save空格（文件名），replace**。和前面介绍的一样，**replace**选项将更新你对数据库的修改，所以一定要小心使用。最好另存一个新的数据库，如果把原始库改了又变不回去，就叫天不应叫地不灵了。  
前面说的都是对单个数据库的简单操作，但有时我们需要改变数据的结构，或者抽取来自不同数据库的信息，因此需要更方便的命令。这一类命令中我用过的有：**改变数据的纵横结构的命令 [reshape](https://zhida.zhihu.com/search?content_id=6839513&content_type=Article&match_order=1&q=reshape&zhida_source=entity)，生成退化的数据库[collapse](https://zhida.zhihu.com/search?content_id=6839513&content_type=Article&match_order=1&q=collapse&zhida_source=entity)，合并数据库的命令append和[merge](https://zhida.zhihu.com/search?content_id=6839513&content_type=Article&match_order=1&q=merge&zhida_source=entity)。**  
纵列（longitudinal）数据通常包括同一个行为者（agent）在不同时期的观察，所以处理这类数据常常需要把数据库从宽表变成长表，或者相反。所谓宽表是以每个行为者为一个观察，不同时期的变量都记录在这个观察下，例如，行为者是厂商，时期有2000、2001年，变量是雇佣人数和所在城市，假设雇佣人数在不同时期不同，所在城市则不变。**宽表记录的格式是每个厂商是一个观察**，没有时期变量，雇佣人数有两个变量，分别记录2000年和2001年的人数，所在城市只有一个变量。**所谓长表是行为者和时期共同定义观察**，在上面的例子中，每个厂商有两个观察，有时期变量，雇佣人数和所在城市都只有一个，它们和时期变量共同定义相应时期的变量取值。  
在上面的例子下，把宽表变成长表的命令格式如下：  
**reshape long （雇佣人数的变量名）, i(（标记厂商的变量名）) j(（标记时期的变量名）)**  
因为所在城市不随时期变化，所以在转换格式时不用放在reshapelong后面，转换前后也不改变什么。相反地，如果把长表变成宽表则使用如下命令  
**reshape wide （雇佣人数的变量名）, i(（标记厂商的变量名）) j(（标记时期的变量名）)**  
唯一的区别是long换成了wide。  
**collapse**的用处是计算某个数据库的一些统计量，再把它存为只含有这些统计量的数据库。用到这个命令的机会不多，我使用它是因为它可以计算中位数和从1到99的百分位数，这些统计量在常规的数据描述命令中没有。如果要计算中位数，其命令的语法如下  
**collapse (median) (（变量名）), by(（变量名）)**  
生成的新数据库中记录了第一个括号中的变量（可以是多个变量）的中位数。右面的by选项是根据某个变量分组计算中位数，没有这个选项则计算全部样本的中位数。  
合并数据库有两种方式，**一种是增加观察，另一种是增加变量**。第一种用**append**，用在两个数据库的格式一样，但观察不一样，只需用**append空格 using空格（文件名）**就可以狗尾续貂了。简单明了，不会有什么错。另一种就不同了，需要格外小心。如果两个数据库中包含共同的观察，但是变量不同，希望从一个数据库中提取一些变量到另一个数据库中用**merge**。完整的命令如下：  
**use （文件名） [打开辅助数据库]**  
**sort （变量名） [根据变量排序，这个变量是两个数据库共有的识别信息]**  
**save （文件名）, replace [保存辅助数据库]**  
**use （文件名） [打开主数据库]**  
**sort （变量名） [对相同的变量排序]**  
**merge （变量名） using （文件名）, keep(（变量名）)**  
**[第一个变量名即为前面sort后面的变量名，文件名是辅助数据库的名字，后面的变量名是希望提取的变量名]**  
**ta _merge [显示_merge的取值情况。_merge等于1的观察是仅主库有的，等于2的是仅辅助库有的，等于3是两个库都有的。]**  
**drop if _merge==2 [删除仅仅来自辅助库的观察]**  
**drop merge [删除_merge]**  
**save （文件名）, replace [将合并后的文件保存，通常另存]**